"""This notebook shows the current state of the newt re-identification models on our dataset."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/03_newt_current.ipynb.

# %% auto 0
__all__ = ['get_newt_dataset', 'get_cropped_newt', 'get_cropping_image_dataset', 'plot_retrieval_results']

# %% ../nbs/03_newt_current.ipynb 4
def get_newt_dataset():
    from wildlife_datasets import datasets
    import os
    import kaggle
    import pandas as pd

    class BarhillNewtsDataset(datasets.WildlifeDataset):
        @classmethod
        def _download(cls, dataset_name, download_path):
            if not os.path.exists(download_path):
                os.makedirs(download_path, exist_ok=True)
                kaggle.api.dataset_download_files(dataset_name, path=download_path, unzip=True)
                print(f"Dataset downloaded to {download_path}")
            else:
                print(f"Dataset already exists at {download_path}")

        def create_catalogue(self) -> pd.DataFrame:
            df = pd.read_csv(os.path.join(self.root, "metadata.csv"))
            return df.rename(columns={"newt_id": "identity", "image_id": "image_name", "image_path": "path"})
    
    return BarhillNewtsDataset

# %% ../nbs/03_newt_current.ipynb 5
def get_cropped_newt(path, rle):
    import cv2
    from gcn_reid.segmentation import decode_rle_mask
    from PIL import Image
    import numpy as np

    img = cv2.imread(path)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

    mask = decode_rle_mask(rle)
    if mask is None: return Image.fromarray(img)
    
    img_array = np.array(img)
    masked_img = img_array * mask[:, :, np.newaxis]
    return Image.fromarray(masked_img)

# %% ../nbs/03_newt_current.ipynb 6
def get_cropping_image_dataset():
    import cv2
    from PIL import Image
    from wildlife_tools.data import ImageDataset

    class CroppingImageDataset(ImageDataset):
        """Dataset that crops an image using an RLE segmentation mask."""
        
        def __init__(self, *image_dataset_args, crop_out=True, rle_col="segmentation_mask_rle", **image_dataset_kwargs):
            super().__init__(*image_dataset_args, **image_dataset_kwargs)
            self.crop_out = crop_out
            self.rle_col = rle_col

        def get_image(self, path):
            img = cv2.imread(path)
            img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

            if not self.crop_out: return Image.fromarray(img)
            
            relative_path = path.replace(self.root, "")[1:] # remove leading /
            rle = self.metadata[self.metadata[self.col_path] == relative_path][self.rle_col].values
            if len(rle) == 0: return Image.fromarray(img)
            return get_cropped_newt(path, rle[0])

    return CroppingImageDataset

# %% ../nbs/03_newt_current.ipynb 21
def plot_retrieval_results(dataset_query, dataset_database, similarity_matrix, crop_out=False, mode = "mistakes", num_results=4, num_queries=5, figsize=(15, 20)):
    """
    Plot retrieval results showing query images and their most similar matches.
    
    Args:
        dataset_query: Query dataset with images and labels
        dataset_database: Database dataset with images and labels
        similarity_matrix: Similarity scores between queries and database
        num_results: Number of top similar images to show per query
        num_queries: Number of query images to display
        figsize: Figure size for the plot
    """
    import matplotlib.pyplot as plt
    import numpy as np
    
    fig, axes = plt.subplots(num_queries, num_results + 1, figsize=figsize)
    
    if mode == "mistakes":
        # We'll identify mistakes by checking if the top match has the same label as query
        # Get top matches for each query
        top_matches = np.argmax(similarity_matrix, axis=1)
        top_match_labels = dataset_database.labels_string[top_matches]
        query_indices = np.where(dataset_query.labels_string != top_match_labels)[0]
    elif mode == "all":
        query_indices = np.arange(len(dataset_query))
    else:
        raise ValueError(f"Invalid mode: {mode}")

    for row, query_idx in enumerate(query_indices[:num_queries]):
        query_label = dataset_query.labels_string[query_idx]
        
        get_image_path = lambda idx, ds: os.path.join(ds.root, ds.df.iloc[idx].path)
        if crop_out:
            query_image = get_cropped_newt(get_image_path(query_idx, dataset_query), dataset_query.df.iloc[query_idx].segmentation_mask_rle)
        else:
            query_image = dataset_query.get_image(query_idx)
        
        # Get top similar images for this query
        similarities = similarity_matrix[query_idx]
        top_indices = np.argsort(similarities)[::-1][:num_results]
        
        # Plot query image
        axes[row, 0].imshow(query_image)
        axes[row, 0].set_title(f'Query: {query_label}', fontweight='bold')
        
        # Set blue border for query image and remove ticks
        for spine in axes[row, 0].spines.values():
            spine.set_edgecolor('blue')
            spine.set_linewidth(3)
        axes[row, 0].set_xticks([])
        axes[row, 0].set_yticks([])
        
        # Plot top similar images
        for col, db_idx in enumerate(top_indices):
            db_label = dataset_database.labels_string[db_idx]
            if crop_out:
                db_image = get_cropped_newt(get_image_path(db_idx, dataset_database), dataset_database.df.iloc[db_idx].segmentation_mask_rle)
            else:
                db_image = dataset_database.get_image(db_idx)    
            similarity_score = similarities[db_idx]
            
            axes[row, col + 1].imshow(db_image)
            axes[row, col + 1].set_title(f'{db_label}\nSim: {similarity_score:.3f}', fontsize=10)
            
            # Set border color based on whether it's a correct match
            border_color = 'green' if db_label == query_label else 'red'
            for spine in axes[row, col + 1].spines.values():
                spine.set_edgecolor(border_color)
                spine.set_linewidth(3)
            axes[row, col + 1].set_xticks([])
            axes[row, col + 1].set_yticks([])
    
    plt.tight_layout()
    plt.suptitle('Retrieval Results: Query (Blue) vs Retrieved Images (Green=Correct, Red=Incorrect)', 
                 fontsize=14, y=1.02)
    plt.show()
